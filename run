#!/usr/bin/env python3 
#!/usr/bin/env python3
"""
gobl3d - Execution Wrapper
Author: oxbv1
Description: Unified wrapper for Go and Bash Gobuster tools with dependency management
"""

import os
import sys
import json
import subprocess
import platform
import shutil
import time
import argparse
from pathlib import Path
from typing import Dict, List, Optional
import tempfile

class Colors:
    """ANSI color codes for terminal output"""
    RED = '\033[0;31m'
    GREEN = '\033[0;32m'
    YELLOW = '\033[1;33m'
    BLUE = '\033[0;34m'
    MAGENTA = '\033[0;35m'
    CYAN = '\033[0;36m'
    WHITE = '\033[1;37m'
    BOLD = '\033[1m'
    NC = '\033[0m'  # No Color

class GobusterSuite:
    def __init__(self):
        self.script_dir = Path(__file__).parent.absolute()
        self.go_module = self.script_dir / ".modulego"
        self.bash_module = self.script_dir / ".modulebash"
        self.config_file = self.script_dir / "config.json"
        self.system = platform.system().lower()
        
    def clear_screen(self):
        """Clear terminal screen"""
        os.system('cls' if os.name == 'nt' else 'clear')
        
    def print_banner(self):
        """Print application banner"""
        banner = f"""
{Colors.CYAN}╔══════════════════════════════════════════════════════════════╗
║                                                              ║
║                   Multi-Tool Execution Wrapper               ║
║                                                              ║
║  🔍 Quick Reconnaissance    🎯 Comprehensive Scans           ║
║  ⚡ Go Performance Tool     🛠️  Bash Flexibility Tool        ║
╚══════════════════════════════════════════════════════════════╝{Colors.NC}

{Colors.YELLOW}[INFO]{Colors.NC} Initializing Ultimate Gobuster Suite...
"""
        print(banner)

    def log_info(self, message: str):
        """Print info message"""
        print(f"{Colors.BLUE}[INFO]{Colors.NC} {message}")

    def log_success(self, message: str):
        """Print success message"""
        print(f"{Colors.GREEN}[SUCCESS]{Colors.NC} {message}")

    def log_error(self, message: str):
        """Print error message"""
        print(f"{Colors.RED}[ERROR]{Colors.NC} {message}")

    def log_warning(self, message: str):
        """Print warning message"""
        print(f"{Colors.YELLOW}[WARNING]{Colors.NC} {message}")

    def run_command(self, command: List[str], capture_output: bool = False, silent: bool = False) -> subprocess.CompletedProcess:
        """Run shell command with error handling"""
        try:
            if silent:
                return subprocess.run(command, capture_output=True, text=True, check=True)
            else:
                return subprocess.run(command, capture_output=capture_output, text=True, check=True)
        except subprocess.CalledProcessError as e:
            if not silent:
                self.log_error(f"Command failed: {' '.join(command)}")
                self.log_error(f"Error: {e}")
            raise

    def check_and_install_dependencies(self):
        """Check and install required dependencies"""
        print(f"\n{Colors.YELLOW}🔧 Setting up...{Colors.NC}")
        
        dependencies = {
            'gobuster': self.check_gobuster,
            'go': self.check_go,
            'git': self.check_git,
            'wordlists': self.check_wordlists
        }
        
        for dep_name, check_func in dependencies.items():
            if not check_func():
                self.install_dependency(dep_name)
        
        self.log_success("All dependencies are ready!")
        time.sleep(1)

    def check_gobuster(self) -> bool:
        """Check if gobuster is installed"""
        try:
            self.run_command(['gobuster', 'version'], capture_output=True, silent=True)
            return True
        except:
            return False

    def check_go(self) -> bool:
        """Check if Go is installed"""
        try:
            self.run_command(['go', 'version'], capture_output=True, silent=True)
            return True
        except:
            return False

    def check_git(self) -> bool:
        """Check if Git is installed"""
        try:
            self.run_command(['git', '--version'], capture_output=True, silent=True)
            return True
        except:
            return False

    def check_wordlists(self) -> bool:
        """Check if common wordlists exist"""
        common_paths = [
            "/usr/share/wordlists/dirb/common.txt",
            "/usr/share/wordlists/dirbuster/directory-list-2.3-medium.txt",
            "/opt/SecLists/Discovery/Web-Content/directory-list-2.3-medium.txt"
        ]
        return any(Path(path).exists() for path in common_paths)

    def install_dependency(self, dependency: str):
        """Install missing dependency"""
        if self.system == "linux":
            self.install_linux_dependency(dependency)
        elif self.system == "darwin":
            self.install_macos_dependency(dependency)
        elif self.system == "windows":
            self.install_windows_dependency(dependency)
        else:
            self.log_error(f"Unsupported system: {self.system}")
            sys.exit(1)

    def install_linux_dependency(self, dependency: str):
        """Install dependency on Linux"""
        install_commands = {
            'gobuster': ['sudo', 'apt-get', 'update', '&&', 'sudo', 'apt-get', 'install', '-y', 'gobuster'],
            'go': ['sudo', 'apt-get', 'install', '-y', 'golang-go'],
            'git': ['sudo', 'apt-get', 'install', '-y', 'git'],
            'wordlists': self.install_wordlists_linux
        }
        
        if dependency in install_commands:
            if dependency == 'wordlists':
                install_commands[dependency]()
            else:
                cmd_str = ' '.join(install_commands[dependency])
                os.system(cmd_str)

    def install_macos_dependency(self, dependency: str):
        """Install dependency on macOS"""
        install_commands = {
            'gobuster': ['brew', 'install', 'gobuster'],
            'go': ['brew', 'install', 'go'],
            'git': ['brew', 'install', 'git'],
            'wordlists': self.install_wordlists_macos
        }
        
        if dependency in install_commands:
            if dependency == 'wordlists':
                install_commands[dependency]()
            else:
                self.run_command(install_commands[dependency], silent=True)

    def install_windows_dependency(self, dependency: str):
        """Install dependency on Windows"""
        self.log_warning("Windows automatic installation not implemented.")
        self.log_info("Please install the following manually:")
        self.log_info("1. Go: https://golang.org/dl/")
        self.log_info("2. Git: https://git-scm.com/download/win")
        self.log_info("3. Gobuster: go install github.com/OJ/gobuster/v3@latest")
        input("Press Enter after installing dependencies...")

    def install_wordlists_linux(self):
        """Install wordlists on Linux"""
        commands = [
            "sudo apt-get install -y wordlists",
            "sudo mkdir -p /opt",
            "cd /opt && sudo git clone https://github.com/danielmiessler/SecLists.git"
        ]
        for cmd in commands:
            try:
                os.system(cmd)
            except:
                continue

    def install_wordlists_macos(self):
        """Install wordlists on macOS"""
        commands = [
            "brew install wordlists",
            "sudo mkdir -p /opt",
            "cd /opt && sudo git clone https://github.com/danielmiessler/SecLists.git"
        ]
        for cmd in commands:
            try:
                os.system(cmd)
            except:
                continue

    def create_modules(self):
        """Create Go and Bash modules if they don't exist"""
        if not self.go_module.exists():
            self.log_warning("Go module (.modulego) not found in current directory")
            self.log_info("Please place the Go gobuster tool as '.modulego' in the same directory")
            
        if not self.bash_module.exists():
            self.log_warning("Bash module (.modulebash) not found in current directory")
            self.log_info("Please place the Bash gobuster tool as '.modulebash' in the same directory")

        # Make modules executable
        if self.go_module.exists():
            self.go_module.chmod(0o755)
        if self.bash_module.exists():
            self.bash_module.chmod(0o755)

    def get_default_config(self) -> Dict:
        """Get default configuration template"""
        return {
            "target": "https://your-target.com",
            "wordlists": [
                "/usr/share/wordlists/dirb/common.txt",
                "/opt/SecLists/Discovery/Web-Content/directory-list-2.3-medium.txt"
            ],
            "extensions": ["php", "html", "txt", "js", "asp", "aspx"],
            "threads": 30,
            "delay": "100ms",
            "timeout": "10s",
            "output_dir": "./gobuster_results",
            "skip_ssl": True,
            "follow_redirects": True,
            "user_agent": "Mozilla/5.0 (compatible; UltimateGobuster/1.0)",
            "status_codes": ["200", "301", "302", "401", "403"],
            "exclude_codes": ["404", "500"]
        }

    def create_config_template(self):
        """Create configuration template"""
        if not self.config_file.exists():
            config = self.get_default_config()
            with open(self.config_file, 'w') as f:
                json.dump(config, f, indent=2)
            self.log_success(f"Configuration template created: {self.config_file}")
        return self.config_file

    def load_config(self) -> Optional[Dict]:
        """Load configuration from file"""
        try:
            with open(self.config_file, 'r') as f:
                return json.load(f)
        except FileNotFoundError:
            return None
        except json.JSONDecodeError as e:
            self.log_error(f"Invalid JSON in config file: {e}")
            return None

    def show_main_menu(self):
        """Display main menu"""
        self.clear_screen()
        self.print_banner()
        
        menu = f"""
{Colors.BOLD}Select Scanning Mode:{Colors.NC}

{Colors.GREEN}1.{Colors.NC} {Colors.CYAN}Quick Reconnaissance{Colors.NC}
   ├─ Fast directory enumeration
   ├─ Common wordlists only  
   ├─ Basic subdomain discovery
   └─ Minimal configuration required

{Colors.GREEN}2.{Colors.NC} {Colors.MAGENTA}Comprehensive Scans with Reporting{Colors.NC}
   ├─ Full directory enumeration
   ├─ Subdomain & VHost discovery
   ├─ Recursive scanning
   ├─ Custom wordlists & extensions
   ├─ Detailed reporting
   └─ Advanced configuration options

{Colors.GREEN}3.{Colors.NC} {Colors.YELLOW}Configuration Management{Colors.NC}
   ├─ Edit configuration file
   ├─ View current settings
   └─ Reset to defaults

{Colors.GREEN}4.{Colors.NC} {Colors.RED}Exit{Colors.NC}

"""
        print(menu)

    def get_target_url(self) -> str:
        """Get target URL from user"""
        while True:
            target = input(f"{Colors.CYAN}Enter target URL{Colors.NC} (e.g., https://example.com): ").strip()
            if target:
                if not target.startswith(('http://', 'https://')):
                    target = 'https://' + target
                return target
            self.log_error("Target URL is required!")

    def quick_reconnaissance(self):
        """Run quick reconnaissance scan"""
        self.clear_screen()
        print(f"{Colors.CYAN}🔍 Quick Reconnaissance Mode{Colors.NC}\n")
        
        target = self.get_target_url()
        
        # Use bash tool for quick scan
        if not self.bash_module.exists():
            self.log_error("Bash module not found! Please ensure .modulebash exists.")
            return
            
        self.log_info("Starting quick reconnaissance scan...")
        
        # Quick scan parameters
        cmd = [
            str(self.bash_module),
            "-t", target,
            "-T", "50",  # More threads for speed
            "--timeout", "5s",  # Shorter timeout
            "--dirs-only",  # Only directory scan
            "--no-recursive",  # No recursive scanning
            "-x", "php,html,txt,js"  # Common extensions only
        ]
        
        try:
            self.run_command(cmd)
            self.log_success("Quick reconnaissance completed!")
        except subprocess.CalledProcessError:
            self.log_error("Quick reconnaissance failed!")
        
        input(f"\n{Colors.YELLOW}Press Enter to continue...{Colors.NC}")

    def comprehensive_scan(self):
        """Run comprehensive scan with reporting"""
        self.clear_screen()
        print(f"{Colors.MAGENTA}🎯 Comprehensive Scan Mode{Colors.NC}\n")
        
        # Check if config exists, create if not
        config_path = self.create_config_template()
        
        print(f"{Colors.YELLOW}Configuration Options:{Colors.NC}")
        print(f"1. Use existing configuration: {config_path}")
        print(f"2. Edit configuration before scan")
        print(f"3. Use interactive setup")
        
        choice = input(f"\n{Colors.CYAN}Select option{Colors.NC} (1-3): ").strip()
        
        if choice == "2":
            self.edit_configuration()
        elif choice == "3":
            self.interactive_setup()
        
        # Load configuration
        config = self.load_config()
        if not config:
            self.log_error("Failed to load configuration!")
            return
            
        # Get target if not set or is default
        if config.get("target") == "https://your-target.com":
            config["target"] = self.get_target_url()
            
        # Choose tool
        print(f"\n{Colors.YELLOW}Select Tool:{Colors.NC}")
        print(f"1. Go Tool (High Performance)")
        print(f"2. Bash Tool (Maximum Flexibility)")
        
        tool_choice = input(f"\n{Colors.CYAN}Select tool{Colors.NC} (1-2): ").strip()
        
        if tool_choice == "1":
            self.run_go_comprehensive(config)
        else:
            self.run_bash_comprehensive(config)
            
        input(f"\n{Colors.YELLOW}Press Enter to continue...{Colors.NC}")

    def run_go_comprehensive(self, config: Dict):
        """Run comprehensive scan using Go tool"""
        if not self.go_module.exists():
            self.log_error("Go module not found! Please ensure .modulego exists.")
            return
            
        self.log_info("Starting comprehensive scan with Go tool...")
        
        # Save updated config
        with open(self.config_file, 'w') as f:
            json.dump(config, f, indent=2)
            
        try:
            cmd = [str(self.go_module), "-config", str(self.config_file)]
            self.run_command(cmd)
            self.log_success("Comprehensive Go scan completed!")
        except subprocess.CalledProcessError:
            self.log_error("Comprehensive Go scan failed!")

    def run_bash_comprehensive(self, config: Dict):
        """Run comprehensive scan using Bash tool"""
        if not self.bash_module.exists():
            self.log_error("Bash module not found! Please ensure .modulebash exists.")
            return
            
        self.log_info("Starting comprehensive scan with Bash tool...")
        
        # Convert config to bash arguments
        cmd = [str(self.bash_module)]
        cmd.extend(["-t", config["target"]])
        cmd.extend(["-T", str(config["threads"])])
        cmd.extend(["-d", config["delay"]])
        cmd.extend(["--timeout", config["timeout"]])
        cmd.extend(["-x", ",".join(config["extensions"])])
        cmd.extend(["-s", ",".join(config["status_codes"])])
        cmd.extend(["-b", ",".join(config["exclude_codes"])])
        cmd.extend(["-a", config["user_agent"]])
        cmd.extend(["-o", config["output_dir"]])
        
        if config["skip_ssl"]:
            cmd.append("--no-ssl-verify")
        if not config["follow_redirects"]:
            cmd.append("--no-follow-redirects")
            
        for wordlist in config["wordlists"]:
            if Path(wordlist).exists():
                cmd.extend(["-w", wordlist])
                break
        
        try:
            self.run_command(cmd)
            self.log_success("Comprehensive Bash scan completed!")
        except subprocess.CalledProcessError:
            self.log_error("Comprehensive Bash scan failed!")

    def interactive_setup(self):
        """Interactive configuration setup"""
        self.clear_screen()
        print(f"{Colors.CYAN}🛠️ Interactive Configuration Setup{Colors.NC}\n")
        
        config = self.get_default_config()
        
        # Get target
        config["target"] = self.get_target_url()
        
        # Get threads
        threads = input(f"Number of threads (default: {config['threads']}): ").strip()
        if threads.isdigit():
            config["threads"] = int(threads)
            
        # Get extensions
        extensions = input(f"File extensions (default: {','.join(config['extensions'])}): ").strip()
        if extensions:
            config["extensions"] = [ext.strip() for ext in extensions.split(',')]
            
        # Get output directory
        output_dir = input(f"Output directory (default: {config['output_dir']}): ").strip()
        if output_dir:
            config["output_dir"] = output_dir
            
        # Save configuration
        with open(self.config_file, 'w') as f:
            json.dump(config, f, indent=2)
            
        self.log_success("Interactive configuration saved!")

    def edit_configuration(self):
        """Edit configuration file"""
        config_path = self.create_config_template()
        
        editors = ['nano', 'vim', 'vi', 'gedit', 'notepad']
        editor = None
        
        for ed in editors:
            if shutil.which(ed):
                editor = ed
                break
                
        if editor:
            try:
                subprocess.run([editor, str(config_path)])
            except:
                self.log_error(f"Failed to open editor: {editor}")
        else:
            self.log_warning("No suitable editor found.")
            self.log_info(f"Please manually edit: {config_path}")

    def configuration_management(self):
        """Configuration management menu"""
        while True:
            self.clear_screen()
            print(f"{Colors.YELLOW}🛠️ Configuration Management{Colors.NC}\n")
            
            print("1. Edit configuration file")
            print("2. View current configuration")
            print("3. Reset to defaults")
            print("4. Back to main menu")
            
            choice = input(f"\n{Colors.CYAN}Select option{Colors.NC} (1-4): ").strip()
            
            if choice == "1":
                self.edit_configuration()
            elif choice == "2":
                self.view_configuration()
            elif choice == "3":
                self.reset_configuration()
            elif choice == "4":
                break
            else:
                self.log_error("Invalid choice!")
                
            if choice in ["2", "3"]:
                input(f"\n{Colors.YELLOW}Press Enter to continue...{Colors.NC}")

    def view_configuration(self):
        """View current configuration"""
        config = self.load_config()
        if config:
            print(f"\n{Colors.CYAN}Current Configuration:{Colors.NC}")
            print(json.dumps(config, indent=2))
        else:
            self.log_warning("No configuration found!")

    def reset_configuration(self):
        """Reset configuration to defaults"""
        config = self.get_default_config()
        with open(self.config_file, 'w') as f:
            json.dump(config, f, indent=2)
        self.log_success("Configuration reset to defaults!")

    def run(self):
        """Main application loop"""
        try:
            # Initial setup
            self.check_and_install_dependencies()
            self.create_modules()
            
            while True:
                self.show_main_menu()
                
                try:
                    choice = input(f"{Colors.CYAN}Enter your choice{Colors.NC} (1-4): ").strip()
                    
                    if choice == "1":
                        self.quick_reconnaissance()
                    elif choice == "2":
                        self.comprehensive_scan()
                    elif choice == "3":
                        self.configuration_management()
                    elif choice == "4":
                        print(f"\n{Colors.GREEN}Thank you for using Ultimate Gobuster Suite!{Colors.NC}")
                        sys.exit(0)
                    else:
                        self.log_error("Invalid choice! Please select 1-4.")
                        time.sleep(2)
                        
                except KeyboardInterrupt:
                    print(f"\n\n{Colors.YELLOW}Scan interrupted by user.{Colors.NC}")
                    time.sleep(1)
                    continue
                    
        except KeyboardInterrupt:
            print(f"\n\n{Colors.GREEN}Goodbye!{Colors.NC}")
            sys.exit(0)
        except Exception as e:
            self.log_error(f"Unexpected error: {e}")
            sys.exit(1)

def main():
    """Main entry point"""
    parser = argparse.ArgumentParser(description="Ultimate Gobuster Suite - Execution Wrapper")
    parser.add_argument("--version", action="version", version="Ultimate Gobuster Suite v1.0")
    parser.add_argument("--setup-only", action="store_true", help="Only setup dependencies and exit")
    
    args = parser.parse_args()
    
    suite = GobusterSuite()
    
    if args.setup_only:
        suite.check_and_install_dependencies()
        suite.create_modules()
        suite.create_config_template()
        print(f"{Colors.GREEN}Setup completed!{Colors.NC}")
        return
    
    suite.run()

if __name__ == "__main__":
    main()
